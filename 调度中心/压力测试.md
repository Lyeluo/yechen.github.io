## 测试内容
1. 调度任务并发数较高时，任务执行成功率  
2. 调度任务执行时间较长时，任务丢弃率
3. 存在多个执行器时，在高压力测试下负载均衡模式是否正常作用
4. 每种测试情况下，调度中心（xxl-job）与执行器（ecs-console）的内存和cpu使用情况，mysql集群压力指标变化情况
5. 每个调度任务执行十五分钟，然后通过调度中心日志查询及运行报表查看任务执行情况，同时通过监控系统查看对应指标变化情况
## GLUE（shell）模式测试
### sql说明
1. 然后在数据库中添加此调度任务，并且默认为开启状态，脚本如下：
```sql
use `xxl-job`;
create procedure job_insert()
begin
    declare i int default 0;
    while i < 500 do
    insert into `xxl-job`.xxl_job_info (job_group, job_cron, job_desc, add_time, update_time, author, alarm_email,
                                        executor_route_strategy, executor_handler, executor_param,
                                        executor_block_strategy,
                                        executor_timeout, executor_fail_retry_count, glue_type, glue_source,
                                        glue_remark,
                                        glue_updatetime, child_jobid, trigger_status, trigger_last_time,
                                        trigger_next_time,
                                        tenant_code, business_id)
    VALUES (10, '0/10 * * * * ?', '压测（shell）', NOW(), null, 'tester', '', 'ROUND', '', '', 'SERIAL_EXECUTION', 0, 0,
            'GLUE_SHELL', '#!/bin/bash

echo "===============调度任务开始执行==============="
sleep 10
echo "===============调度任务执行结束==============="
exit 0
', '脚本初始化', NOW(), '', 1, 0, 0, null, null);
    set i = i + 1;
    end while;
end;

call job_insert();
```
- 可以通过修改`i`的值，修改测试调度任务的个数。新创建完毕的调度任务默认处于开启状态
- 开启调度任务sql
```sql
update xxl_job_info set trigger_status = 1 where job_desc = '压测（shell）' and trigger_status=0;
```
- 关闭调度任务sql
```sql
update xxl_job_info set trigger_status = 0 where job_desc = '压测（shell）' and trigger_status=1;
```
- 注意：在切换调度中心开启或关闭时，可能会因为调度任务正在执行，触发事务，导致批量切换时部分任务状态切换失败，所以切换完毕后
可以通过以下sql查询对应的任务状态是否已全部切换完毕。  
`trigger_status=0` 调度任务开启；`trigger_status=1`调度任务关闭
```sql
select count(0) from xxl_job_info where job_desc = '压测（shell）'and trigger_status=0;
```
- 清空表数据sql
```sql
# 清空调度任务
truncate table xxl_job_info;
# 清空调度日志
truncate table xxl_job_log;
# 清空调度报表
truncate table xxl_job_log_report;
```
### 场景测试
1. 同时开启500个调度任务，查看执行结果；  
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，调度任务正常执行，个别（约400个以后创建的任务）执行次数时间会出现1s左右的误差
```
2. 同时开启1000个调度任务，查看执行结果；    
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，但是执行周期与cron配置不匹配，内存也没有明显提升。
```
3. 扩展ecs-console的实例数量为两个（利用rancher(k8s)增加实例能力），同时开启1000个调度任务，查看执行结果；
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，但是执行周期与cron配置不匹配，内存也没有明显提升。
```
4. 扩展ecs-console的实例数量为两个，xxl-job的实例数量为两个（利用rancher(k8s)增加实例能力），同时开启1000个调度任务，查看执行结果；  
预期结果为：
```
任务可以全部正常执行，但是执行周期与cron配置不匹配，通过查看xxl-job的日志发现，两个调度中都有执行任务
一段时间后报错RejectedExecutionException，triggerpool线程池爆满
```

## BEAN 模式测试
1. 然后在数据库中添加此调度任务，并且默认为开启状态，脚本如下：
```sql
use `xxl-job`;
create
    definer = root@`%` procedure job_bean_insert()
BEGIN
    DECLARE
        i INT DEFAULT 0;
    WHILE i < 500 DO
    INSERT INTO `xxl-job`.xxl_job_info ( job_group, job_cron, job_desc, add_time, update_time, author, alarm_email,
                                        executor_route_strategy, executor_handler, executor_param,
                                        executor_block_strategy, executor_timeout, executor_fail_retry_count, glue_type,
                                        glue_source, glue_remark, glue_updatetime, child_jobid, trigger_status,
                                        trigger_last_time, trigger_next_time, tenant_code, business_id)
    VALUES ( 11, '0/5 * * * * ?', '压测(bean)', '2021-07-19 15:28:39', '2021-07-19 15:28:39', 'liujy', '', 'ROUND',
            'YN_PLATFORM_LOG_EXCEPTION_CLEAN_JOB', '7', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2021-07-19 15:28:39', '', 1, 0, 0,
            null, null);
    SET i = i + 1;
    END
    WHILE;
END;

call job_bean_insert();
```
- 可以通过修改`i`的值，修改测试调度任务的个数。新创建完毕的调度任务默认处于开启状态
- 开启调度任务sql
```sql
update xxl_job_info set trigger_status = 1 where job_desc = '压测(bean)' and trigger_status=0;
```
- 关闭调度任务sql
```sql
update xxl_job_info set trigger_status = 0 where job_desc = '压测(bean)' and trigger_status=1;
```
- 注意：在切换调度中心开启或关闭时，可能会因为调度任务正在执行，触发事务，导致批量切换时部分任务状态切换失败，所以切换完毕后
可以通过以下sql查询对应的任务状态是否已全部切换完毕。  
`trigger_status=0` 调度任务开启；`trigger_status=1`调度任务关闭
```sql
select count(0) from xxl_job_info where job_desc = '压测（shell）'and trigger_status=0;
```
- 清空表数据sql
```sql
# 清空调度任务
truncate table xxl_job_info;
# 清空调度日志
truncate table xxl_job_log;
# 清空调度报表
truncate table xxl_job_log_report;
```
### 场景测试
1. 同时开启500个调度任务，查看执行结果；  
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，调度任务全部正常执行
```
2. 同时开启1000个调度任务，查看执行结果；    
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，前期个别调度会出现1s左右误差，后续调度慢慢正常
```
3. 扩展ecs-console的实例数量为两个（利用rancher(k8s)增加实例能力），同时开启1000个调度任务；  
查看执行结果，预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，调度任务全部正常执行
```
4. 扩展ecs-console的实例数量为两个，xxl-job的实例数量为两个（利用rancher(k8s)增加实例能力），同时开启1000个调度任务，查看执行结果；  
预期结果为：
```
任务全部可以正常执行，通过查看调度任务执行日志及运行报表发现，前期个别调度会出现1s左右误差，后续调度慢慢正常
```
